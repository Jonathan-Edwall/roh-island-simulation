---
title: "Selection Scenario simulation for Dogs in AlphaSimR"
output:
  html_document:
    toc: true
    toc_depth: 3  
date: "2025-04-27"
editor_options: 
  markdown: 
    wrap: 72
---

# 0: Preparation

## Defining the output directory & the chromosome to be simulated

```{r}
# Clean the working environment
rm(list = ls())

knitr::opts_chunk$set(echo = TRUE)

use_chromosome_specific_recombination_rate <- as.logical("TRUE")
# use_chromosome_specific_recombination_rate <- as.logical("FALSE")

# Set the path to your GitHub folder
YOUR_GITHUB_ROOT_DIRECTORY <- "C:/Users/jonat/GitHub"

# Defining the relative path in the repository
repository_path <- "Computational-modelling-of-genomic-inbreeding-and-roh-islands-in-extremely-small-populations"

#################################### 
# Defining Input parameters
#################################### 
chromosome_end_margin <- 0.15 # The chosen causative variant must be positioned at least within  15 % of the chromosome ends
s <- 0.8
# Print the value of selection_coefficient
cat("Selection Coefficient:", s, "\n")
allele_copies_threshold <- 2 # 10 default (candidate_variants = less than 10)
# Simulate_Hard_Sweep <- as.logical("TRUE")
Simulate_Hard_Sweep <- as.logical("FALSE")
Variant_One_Individual_Origin <-  as.logical("TRUE")

fixation_threshold_causative_variant <- 0.99
disappearance_threshold_value_to_terminate_script <- 1

# min_MAF <- 0.05 #(minimum allowed Minor Allele Frequency for each SNP)
chr_simulated <- "chr3"
# Extract the chromosome number and convert and convert it to numeric
chr_number <- as.numeric(sub("chr", "", chr_simulated))

# Extracting the physical length of the model chromosome to be simulated
model_chromosome_physical_length_bp <- 92479059 

# Extracting the recombination rate of the simulated chromosome 
model_chromosome_recombination_rate <- 0.69
average_recombination_rate <- 1.0734

# N_e_burn_in <- 250 # Ancestral Population
N_e_burn_in <- 2130

Inbred_ancestral_population <- as.logical("FALSE")
# Inbred_ancestral_population <- as.logical("TRUE")

nInd_founder_population <- 5
n_bottleneck <- 5

n_generations_bottleneck <- 1

n_generations_mate_selection <-  88

n_indv_breed_formation <- 295

Ref_pop_snp_chip <- "last_breed_formation_generation"
# Ref_pop_snp_chip <- "last_bottleneck_generation"

# Set the estimated mutation rate for the studies species.
# By default, the estimated mutation rate for dogs by (Lindblad-Toh et al.2005), 1 × 10−8 mutations per base pair per generation, is used.
mutation_rate <- 1*10^-8
# introduce_mutations <- as.logical("FALSE")
introduce_mutations <- as.logical("TRUE")

snp_density_Mb <- 91.23
snp_density_Mb
####################################  
# Defining output files
#################################### 
output_sim_files_basename <- "sim_1_selection_model_s08_chr3"

output_dir_simulation <- file.path(YOUR_GITHUB_ROOT_DIRECTORY, repository_path,"data/raw/simulated/selection_model")

if (!dir.exists(output_dir_simulation)) {
  # Create the working directory if it doesn't exist
  dir.create(output_dir_simulation, recursive = TRUE)
}

pruned_counts_dir <- file.path(output_dir_simulation,"pruned_counts")

if (!dir.exists(pruned_counts_dir)) {
  # Create the working directory if it doesn't exist
  dir.create(pruned_counts_dir, recursive = TRUE)
}

simulation_prune_count_file <- file.path(pruned_counts_dir, "pruned_replicates_count_s_0.8.tsv")

# Define the path for the simulation status file
simulation_status_file <- file.path(pruned_counts_dir, "simulation_status_file")

# Create an empty file if it doesn't exist
if (!file.exists(simulation_status_file)) {
  file.create(simulation_status_file)
}

variant_position_dir <- file.path(output_dir_simulation,"variant_position")
if (!dir.exists(variant_position_dir)) {
  # Create the working directory if it doesn't exist
  dir.create(variant_position_dir, recursive = TRUE)
}
variant_positions_file <- file.path(variant_position_dir, "variant_position_s_0.8.tsv")

image_output_dir <- file.path(output_dir_simulation,"variant_freq_plots")
if (!dir.exists(image_output_dir)) {
  # Create the working directory if it doesn't exist
  dir.create(image_output_dir, recursive = TRUE)
}
# # Set the working directory for notebook chunks
# knitr::opts_knit$set(root.dir = output_dir_simulation)
# # Verify the current working directory
#getwd()
```

## Loading libraries
```{r library()}
library(AlphaSimR)
library(knitr)

```
# 1: Creating founder Haplotypes
## 1.0: Defining physical chromosome lengths of model species
Chromosome lengths of the dog autosome, derived from the canine reference assembly UU_Cfam_GSD_1.0,
which can be found through this link:
https://www.ncbi.nlm.nih.gov/datasets/genome/GCF_011100685.1/
```{r}
chromosome_lengths_bp <- c(
"chr1" = 123556469, "chr2" = 84979418, "chr3" = 92479059, "chr4" = 89535178	, "chr5" = 89562946, 
"chr6" = 78113029	, "chr7" = 81081596, "chr8" = 76405709, "chr9" = 61171909, "chr10" = 70643054, 
"chr11" = 74805798, "chr12" = 72970719, "chr13" = 64299765, "chr14" = 61112200, "chr15" = 64676183, 
"chr16" = 60362399, "chr17" = 65088165, "chr18" = 56472973, "chr19" = 55516201, "chr20" = 58627490, 
"chr21" = 51742555, "chr22" = 61573679, "chr23" = 53134997, "chr24" = 48566227, "chr25" = 51730745, 
"chr26" = 39257614, "chr27" = 46662488, "chr28" = 41733330, "chr29" = 42517134, "chr30" = 40643782, 
"chr31" = 39901454, "chr32" = 40225481, "chr33" = 32139216, "chr34" = 42397973, "chr35" = 28051305, 
"chr36" = 31223415, "chr37" = 30785915, "chr38" = 24803098	
)

```
## 1.1 Genetic chromosome lengths
### 1.1.1 Defining recombination rates for the model species
The used chromosomal recombination rates of the dog autosome comes from the canine linkage map produced by the paper Wong et al. 2010.
The table from which the values comes from, can be found through this link:
https://www.researchgate.net/figure/Physical-and-genetic-lengths-of-dog-chromosomes_tbl3_40453037
```{r}
chromosome_recombination_rates_cM_Mb <- c(
"chr1" = 0.68, "chr2" = 0.88, "chr3" =0.69, "chr4" = 0.75, "chr5" = 0.85, 
"chr6" = 0.71, "chr7" = 0.75 , "chr8" = 0.83, "chr9" = 1.11, "chr10" = 0.78, 
"chr11" = 0.84, "chr12" = 0.87, "chr13" = 0.90, "chr14" = 0.89, "chr15" = 0.80, 
"chr16" = 0.90, "chr17" = 0.89, "chr18" = 0.88, "chr19" = 0.93, "chr20" = 0.93, 
"chr21" = 1.02, "chr22" = 0.84, "chr23" = 1.02, "chr24" = 1.13, "chr25" = 1.05, 
"chr26" = 1.22, "chr27" = 1.18, "chr28" =1.31, "chr29" = 1.15, "chr30" = 1.36, 
"chr31" = 1.29, "chr32" = 1.37, "chr33" = 1.53, "chr34" = 1.17, "chr35" = 2.15, 
"chr36" = 1.54, "chr37" = 1.38, "chr38" = 2.22 	
)

```

### 1.1.2 Defining physical chromosome lengths of model species
```{r}
# Extracting the physical length of the simulated chromosome 
# model_chromosome_physical_length_bp <- chromosome_lengths_bp[chr_simulated]

if (use_chromosome_specific_recombination_rate) {
  # Extracting the recombination rate of the simulated chromosome 
  # model_chromosome_recombination_rate <- chromosome_recombination_rates_cM_Mb[chr_simulated]
  cat("Recombination rate:",model_chromosome_recombination_rate)
  # Computing the genetic length of the simulated chromosome 
  model_chromosome_genetic_length_morgan <- (model_chromosome_physical_length_bp*10^-6)*(model_chromosome_recombination_rate*10^-2)
   cat("Genetic Length in Morgan:",model_chromosome_genetic_length_morgan)
} else {
  # Setting the average recombination rate for dogs.
  # average_recombination_rate <- 0.97
  # average_recombination_rate <- mean(chromosome_recombination_rates_cM_Mb)
  
  # Computing the genetic length of the simulated chromosome 
  model_chromosome_genetic_length_morgan <- (model_chromosome_physical_length_bp*10^-6)*(average_recombination_rate*10^-2)
  model_chromosome_genetic_length_morgan
}

```

## 1.2: runMacs2() - Generating founder population
`runMacs2` Parameters:

-   nInd = 100: 100 individuals in the founder population

-   nChr = 1: Haplotypes are created for 1 chromosome per individual

-   Ne = 2500: Effective population size: 2500 (Ne)

-   bp: base pair length of chromosome

-   genLen = 1: Genetic length of chromosome in Morgans, set as 1.

-   HistNe = NULL: No effective population size defined from previous
    generations (histNe = NULL)

-   histGen = NULL: If HistNe was defined, this parameter would define
    the number of generations ago we had the Ne defined in HistNe

```{r runMacs2()}
#help(runMacs2)

# mutation_rate <- 1*10^-8
n_bottleneck
N_e_burn_in
model_chromosome_physical_length_bp
Inbred_ancestral_population
model_chromosome_genetic_length_morgan
mutation_rate

founderGenomes <- runMacs2(nInd = n_bottleneck ,
                     nChr = 1,
                     Ne = N_e_burn_in,
                     bp = model_chromosome_physical_length_bp,
                     inbred = Inbred_ancestral_population,
                     genLen = model_chromosome_genetic_length_morgan,
                     mutRate = mutation_rate,
                     histNe = NULL,
                     histGen = NULL)

# Inspecting the founderGenomes object
founderGenomes

```

## 1.3: SimParam() - Setting Global Simulation Parameters
```{r SimParam()}
#help(SimParam)
# Creating a new Simparam object & Assigning the founder population population to it
SP <- SimParam$new(founderGenomes)
# SP
```
### 1.3.1: \$setTrackRec() - Setting on recombination tracking for the simulation
Sets recombination tracking for the simulation. By default recombination
tracking is turned off. **When turned on recombination tracking will
also turn on pedigree tracking.**
**Recombination tracking keeps records of all individuals created,**
except those created by hybridCross, because their pedigree is not
tracked.
```{r SimParam$setTrackRec()}
SP$setTrackRec(TRUE)
```

## 1.4: newPop() - Creating two separate populations for bottleneck event
```{r newPop()}
# Generate the initial founder population
founderpop <- newPop(founderGenomes, simParam = SP)
# # Set misc used for setting years of birth for the first individuals
# current_generation <- 0
# founderpop <- setMisc(x = founderpop,
#                    node = "generation",
#                    value = current_generation)
# head(getMisc(x = founderpop, node = "generation"))
# 
# Split the founder population into two breeding groups
breed1_founders <- founderpop[1:n_bottleneck] # 1:50
cat("Population 1:\n")
breed1_founders

# breed2_founders <- founderpop[(n_bottleneck + 1):(2 * n_bottleneck)] # 51:100
# cat("Population 2:\n")
# breed2_founders
```

# 2: Forward in time simulation
## 2.0: Defining Random Mating function (random_mating_bottleneck) - randCross()
`randCross()` simulates random mating.

-   **nCrosses**-argument specifies how many times an individual in the
    population can be a parent. In this case, an individual can only be
    a parent once (random mating)

-   **nProgeny**-argument specifies how many progeny's each mating pair
    can have. In this case, this parameter is set at 1 progeny per
    mating pair.

-   **simParam**-argument specifies the global simulation parameters

```{r}
random_mating_bottleneck <- function(pop, SP, n_gen,n_bottleneck, introduce_mutations,mutation_rate) {
    n_ind <- pop@nInd # Extracting number of individuals in the current population
    generations <- vector(length = n_gen + 1,
                          mode = "list") 
    generations[[1]] <- pop # The initial breeding group population gets stored as the first element
    
    # Simulating random mating to perform simulation of the 2nd until the n+1:th generation
    # Each mating Progenys are generated using randcross
    for (gen_ix in 2:(n_gen + 1)) {
        # Initialize vectors for parents
        parent1 <- integer(generations[[gen_ix - 1]]@nInd)
        parent2 <- integer(generations[[gen_ix - 1]]@nInd)
        # Create mating pairs
        for (i in 1:n_bottleneck) {
            # Sample parent1
            parent1[i] <- sample(1:generations[[gen_ix - 1]]@nInd, 1)
            # Ensure parent2 is different from parent1
            repeat {
                parent2[i] <- sample(1:generations[[gen_ix - 1]]@nInd,1)
                if (parent2[i] != parent1[i]) break
            }
        }
        # Crossing parents to create next generation
        generations[[gen_ix]] <- makeCross(generations[[gen_ix - 1]],
                                            cbind(parent1, parent2),
                                            nProgeny = 1,
                                            simParam = SP)
      
        # generations[[gen_ix]] <- randCross(pop=generations[[gen_ix - 1]], nCrosses = n_ind, nProgeny = 1,
        #                                    simParam = SP)
        # Introducing mutations
        if (introduce_mutations == TRUE) {
          generations[[gen_ix]] <- AlphaSimR::mutate(generations[[gen_ix]],mutRate = mutation_rate, simParam = SP)
        }

        
    }
     random_mating_generations <- generations[-1] #all generations except for the founder population gets returned (the simulated generations derived from the bottleneck)
    
    return(random_mating_generations)
}

```
## 2.1: Bottleneck Simulation 

### 2.1.1 Simulating 5 generations of bottleneck (Random Mating)

```{r Bottleneck scenario simulation}
if (n_generations_bottleneck > 0) {
  # Simulating random mating within each breeding group for 5 generations
  breed1_bottleneck <- random_mating_bottleneck(breed1_founders, SP, n_generations_bottleneck, n_bottleneck, introduce_mutations, mutation_rate)
}
```


### 2.1.2 Extracting the final bottleneck generation

```{r}
# Viewing the output
# founders
founderpop

if (n_generations_bottleneck == 0) {
  last_bottleneck_generation <- breed1_founders
} else {
  breed1_bottleneck
  # Extracting final generation:
  last_bottleneck_generation <- breed1_bottleneck[[n_generations_bottleneck]]
}
cat("Extracting the final generation from the Bottleneck Scenario")
last_bottleneck_generation
```

## 2.2: Adding SNPs to the last bottleneck generation - SimParam\$addSnpChip() 
`SP$addSnpChip()` Randomly assigns eligible SNPs to a SNP chip.

**nSnpPerChr**-argument that assigns for each individuals n SNPs for
each chromsome, where n is the user-specified number.

**minSnpFreq**-argument sets the Minimum Allele Frequency (MAF) allowed
for each marker. For instance, setting minSnpFreq = 0.05 ensures that
all markers will have MAF \>= 0.05

**refPop**-argument specifies which population will be genotyped. In
this case, it will be the last_bottleneck_generation after the simulated population
bottleneck scenario.

```{r SimParam$addSnpChip()}
model_chromosome_Mb_length <- model_chromosome_physical_length_bp / (10^6)
num_snp_markers_simulated_chromosome <- snp_density_Mb * model_chromosome_Mb_length

if (num_snp_markers_simulated_chromosome > founderGenomes@nLoci) {
  cat("Reference amount of SNP markers for ",chr_simulated, ": ",num_snp_markers_simulated_chromosome)
  cat("\n",num_snp_markers_simulated_chromosome," > ",founderGenomes@nLoci)
  cat("\n Burn in N_e: ", N_e_burn_in,"\n")
  num_snp_markers_simulated_chromosome <- founderGenomes@nLoci
  new_SNP_density <- num_snp_markers_simulated_chromosome / model_chromosome_Mb_length
  cat("\n Old SNP density: ",snp_density_Mb," markers/Mb")
  cat("\n New SNP density: ",new_SNP_density," markers/Mb")
} else {
  cat("Reference amount of SNP markers for ",chr_simulated, ": ",num_snp_markers_simulated_chromosome)
  cat("\n",num_snp_markers_simulated_chromosome," < ",founderGenomes@nLoci)
  cat("\n Burn in N_e: ", N_e_burn_in,"\n")
}

# Check if Ref_pop_snp_chip is equal to last_bottleneck_generation
if (Ref_pop_snp_chip == "last_bottleneck_generation") {
  SP$addSnpChip(
    nSnpPerChr = num_snp_markers_simulated_chromosome,
    refPop = last_bottleneck_generation
  )
}

```
## 2.3 Simulating the selection scenario - makeCross()
`makeCross()` Parameters:
### 2.3.1 find_causative_variant() - Function for finding the causative variant
```{r Finding Causative variant}
find_causative_variant <- function(population, SP, allele_copies_threshold, chromosome_end_margin, model_chromosome_physical_length_bp, model_chromosome_genetic_length_morgan, Simulate_Hard_Sweep, Variant_One_Individual_Origin) {
     minimum_position_buffer_from_chromosome_end <- 100001

    upper_boundary_position_margin <- model_chromosome_physical_length_bp - minimum_position_buffer_from_chromosome_end
    lower_boundary_position_margin <- minimum_position_buffer_from_chromosome_end

    # Extract the genetic map 
    gen_map <- getGenMap(founderGenomes)
    pop_haplotypes <- pullSegSiteHaplo(last_bottleneck_generation, simParam = SP)

    # Count occurrences of each variant
    count <- colSums(pullSegSiteGeno(last_bottleneck_generation, simParam = SP))
    # Initialize success variable
    success <- FALSE
    causative_variant <- NULL  # Always initialize causative_variant
    # Determine candidate variants based on sweep type
    if (Simulate_Hard_Sweep == FALSE) {
        if (allele_copies_threshold < 2) {
            allele_copies_threshold <- 2 
        }
        # Soft sweep: Only variants with allele copies equal to the threshold
        if (Variant_One_Individual_Origin == TRUE) {
            allele_copies_threshold <- 2  
        }
        candidate_variants <- which(count == allele_copies_threshold)
        length(candidate_variants)
        View(candidate_variants)
    } else {
        # Hard sweep: 
        # Adjusting the allele copies threshold if it's wrongfully larger than 2
        allele_copies_threshold <- 1
        candidate_variants <- which(count == allele_copies_threshold)
        length(candidate_variants)
        # View(candidate_variants)
    }

    if (length(candidate_variants) > 1) {
      # Randomly shuffle the list of variants
      candidate_variants_random_order <- candidate_variants[sample(1:length(candidate_variants))]

      # Iterate through the elements in the shuffled random order
      for (i in seq_along(candidate_variants_random_order)) {
          variant <- candidate_variants_random_order[i]
          variant_SNP_ID <- names(variant)
  
          # Determine the position of the variant on the genetic map 
          variant_relative_SNP_POS <- gen_map[gen_map$id == variant_SNP_ID, ]
          variant_SNP_physical_POS <- round(
              (variant_relative_SNP_POS$pos / model_chromosome_genetic_length_morgan) * model_chromosome_physical_length_bp
          )
  
          # Ensure the variant is within allowed position margins
          if (variant_SNP_physical_POS >= lower_boundary_position_margin && variant_SNP_physical_POS <= upper_boundary_position_margin) {
              # If simulating a hard sweep
              if (Simulate_Hard_Sweep == TRUE) {
                  column_index <- as.integer(sub(".*_", "", variant_SNP_ID))  # Extract number after "_"
                  variant_column <- pop_haplotypes[, column_index]

                  print(variant_column) 
                  success <- TRUE
                  causative_variant <- variant
                  cat("Success! Causative Variant found for the Hard Sweep simulation \n")
                  break
              } else {
                  # Soft sweep simulation
                  column_index <- as.integer(sub(".*_", "", variant_SNP_ID))  # Extract number after "_"
                  variant_column <- pop_haplotypes[, column_index]
                  # print(variant_column)
  
                  # Extract individual identifiers and sum haplotype values per individual
                  individuals <- sub("_.*", "", names(variant_column))
                  variant_column_individuals <- tapply(variant_column, individuals, sum)
  
                  # Check if at least 2 individuals carry the variant
                  if (sum(variant_column_individuals == 1 | variant_column_individuals == 2) >= 2) {
                      if (Variant_One_Individual_Origin == FALSE) {
                         # If soft sweep (likely single-origin soft sweep)
                         # Allow if multiple individual carries it
                        print(variant_column)
                        success <- TRUE
                        causative_variant <- variant
                        cat("Success! Causative Variant found for the Soft Sweep simulation \n")
                        break
                        }
                  } else {
                      if (Variant_One_Individual_Origin == TRUE) {
                          # If soft sweep (likely multi-origin soft sweep)
                          # Allow even if only one individual carries it
                          print(variant_column)
                          success <- TRUE
                          causative_variant <- variant
                          cat("Success!  Causative Variant found for the Soft Sweep simulation \n")
                          cat("Only one individual carries the allele and is homozygous for it.\n")
                          break
                      }
                  }
              }
          }
      }
      

    }
  # View(variant) 
  # View(candidate_variants_random_order[i])

  return(causative_variant)
}


# Extract the genetic map 
gen_map <- getGenMap(founderGenomes)

# Count occurrences of each variant
count <- colSums(pullSegSiteGeno(last_bottleneck_generation, simParam = SP))

allele_copies_list <- c(0,1,2,3,4,5,6,7,8,9,10)
for (allele_copy_num in allele_copies_list) {
  # Find candidate variants (less than or equal to the threshold)
  candidate_variants <- which(count == allele_copy_num)
  cat("\n",length(candidate_variants),"variants found,with", allele_copy_num, "allele copies")
}

for (allele_copy_num in allele_copies_list) {
  # Find candidate variants (less than or equal to the threshold)
  candidate_variants <- which(0 < count & count <= allele_copy_num)
  cat("\n",length(candidate_variants),"variants found,with 0 <  ", allele_copy_num, "<= allele copies")
}

upper_limit_allele_copies <- n_bottleneck*2
allele_copies_listt <- c(10,upper_limit_allele_copies)
for (allele_copy_num in allele_copies_listt) {
  # Find candidate variants (less than or equal to the threshold)
  candidate_variants <- which(count > allele_copy_num)
  cat("\n\n",length(candidate_variants),"variants found,with more than", allele_copy_num, "allele copies")
  # Find candidate variants (less than or equal to the threshold)
  candidate_variants <- which(count == allele_copy_num)
  cat("\n",length(candidate_variants),"variants found,with", allele_copy_num, "allele copies")
}
```
### 2.3.2 Selecting The Causative Variant
```{r Selecting Causative Variant}
# Function to randomly pick out a causative variant to be studied
causative_variant <- find_causative_variant(last_bottleneck_generation, SP, allele_copies_threshold,chromosome_end_margin,model_chromosome_physical_length_bp, model_chromosome_genetic_length_morgan, Simulate_Hard_Sweep, Variant_One_Individual_Origin) 

# Initialize a global flag
run_chunks <- TRUE

# Updating the status file.
# Exiting the script if no causative variant was found (FALSE)
if (is.null(causative_variant)) {
    writeLines("FALSE", con = simulation_status_file)  # Log failure
    run_chunks <- FALSE
    cat("Causative variant not found. Status written to file.\n")
    knitr::knit_exit()  # Exit the Rmd if needed
} else {
    writeLines("TRUE", con = simulation_status_file)  # Log success
    cat("Causative variant found. Status written to file.\n")
}
```
### 2.3.3 Defining the Mate selection function - Mate_Selection_scenario()
```{r}
Mate_Selection_scenario <- function(selection_scenario_pop,SP, n_generations_mate_selection,n_indv_breed_formation,introduce_mutations,mutation_rate, causative_variant,s) {
  
    # Creating a vector to store the allele frequency of the causative variant over the selection simulation generations
    f_causative <- numeric(n_generations_mate_selection)
    
    generations <- vector(length = n_generations_mate_selection + 1,
                          mode = "list") 
  
    
    generations[[1]] <- selection_scenario_pop # The initial breeding group population gets stored as the first element
      
    
    # Performing the Mate selection. Each mating pair has 1 progeny
    for (gen_ix in 2:(n_generations_mate_selection + 1)) {
        # Retrieves the genotype of the causative variant for each individual in the population 
        geno <- pullSegSiteGeno(generations[[gen_ix - 1]], simParam = SP)[, causative_variant]
        # Calculate allele frequency of the causative variant
        f_causative[gen_ix-1] <- sum(geno) / length(geno) / 2
        frequency_drop <- 1
        # Check if the causative variant is lost (allele frequency drops to 0)
        if (f_causative[gen_ix-1] == 0) {
            cat("\nTerminating simulation: The causative variant has been completely lost by generation", gen_ix - 1, ".\n")
            return(list(f_causative[1:(gen_ix-1)], generations[[gen_ix-1]])) # Exit early
        }
        # Check if half the generations have passed and the allele frequency has dropped 20-fold
        else if ( gen_ix == ceiling(n_generations_mate_selection / 2) && 
                 f_causative[gen_ix-1] <= (f_causative[1] / frequency_drop) ) {
            cat("\nTerminating simulation: After half the generations (", gen_ix - 1, 
                ") the allele frequency has dropped more than 20-fold from its initial value.\n")
            return(list(f_causative[1:(gen_ix-1)], generations[[gen_ix-1]])) # Exit early
        }

        #     # Print out the genotype of each individual
        # for (i in 1:length(geno)) {
        #   if (geno[i] == 2) {
        #     cat("Generation", gen, "- Individual", i, "is homozygous for the causative variant (AA)\n")
        #   } else if (geno[i] == 1) {
        #     cat("Generation", gen, "- Individual", i, "is heterozygous (Aa)\n")
        #   } else if (geno[i] == 0) {
        #     cat("Generation", gen, "- Individual", i, "is homozygous for the non-causative variant (aa)\n")
        #   }
        # }
        
        # # Old fitness function
        # fitness <- rep(1-s, length(geno)) # If homozygous for the non-causative variant
        # fitness[geno == 1] <- 1 - (s/2) # If heterozygous for the selected allele of the causative variant
        # fitness[geno == 2] <- 1 # If homozygous for the selected allele of the causative variant

        
        # Set fitness based on genotype
        fitness <- rep(1, length(geno)) # If homozygous for the non-causative variant
        fitness[geno == 1] <- 1 + (s/2) # If heterozygous for the selected allele of the causative variant
        fitness[geno == 2] <- 1 + s # If homozygous for the selected allele of the causative variant

        # Initialize vectors for parents
        parent1 <- integer(n_indv_breed_formation)
        parent2 <- integer(n_indv_breed_formation)
        
        # Biased sampling of parents based on fitness
        # Create mating pairs
        for (i in 1:n_indv_breed_formation) {
            # Sample parent1
            parent1[i] <- sample(1:generations[[gen_ix - 1]]@nInd, 1, replace = TRUE, prob = fitness)
            # Ensure parent2 is different from parent1
            repeat {
                parent2[i] <- sample(1:generations[[gen_ix - 1]]@nInd,1, replace = TRUE, prob = fitness)
                if (parent2[i] != parent1[i]) break
            }
        }
        
        # Crossing parents to create next generation
        generations[[gen_ix]] <- makeCross(generations[[gen_ix - 1]],
                                            cbind(parent1, parent2),
                                            nProgeny = 1,
                                            simParam = SP)
        
        # Introducing mutations
        if (introduce_mutations == TRUE) {
          generations[[gen_ix]] <- AlphaSimR::mutate(generations[[gen_ix]],mutRate = mutation_rate, simParam = SP)
        }
        
  }
    
  selection_scenario_pop_final_generation <- generations[[n_generations_mate_selection+1]] # Final generation extracted
  
  return(list(f_causative,selection_scenario_pop_final_generation))
  
}
```
### 2.3.4 Simulating the selection scenario - makeCross()
```{r Simulating the selection scenario, echo = TRUE} 
if (run_chunks) {
  # Create a counter for tracking each time the conditional simulations have to be rerun 
  # Due to the causative variant not getting fixated within the forward simulation or have become lost due to drift.
  disappearance_counter <- 0
  
  # Extract the highest IID in the population from the post bottleneck scenario
  # last_bottleneck_IID <- max(last_bottleneck_generation@id)
  
  # Print the chosen causative variant
  cat("Variant chosen:\n", causative_variant)
  
  # Define the rerun mechanism
  success <- FALSE
  while (!success) {
      # Sets the initial population for the selection scenario to the last generation of the bottleneck simulation.
      selection_scenario_pop <- last_bottleneck_generation
      # Run the simulation, starting with the last generation of the bottleneck simulation as 
      # The initial population for the selection scenario
      result <- Mate_Selection_scenario(selection_scenario_pop,SP, n_generations_mate_selection,n_indv_breed_formation,introduce_mutations,mutation_rate,causative_variant,s)
    
      f_causative <- result[[1]]
      fixation_threshold_causative_variant 
      
      # Check if the causative variant has been fixated  
      if (max(f_causative) >= fixation_threshold_causative_variant) {
          success <- TRUE
          last_mate_selection_generation <- result[[2]]
          causative_variant_SNP_ID <- names(causative_variant)
          #SP$addSnpChipByName(causative_variant_SNP_ID) # Creating a SNP chip only consisting of this causative variant
          # Future change?: create a new snp chip that includes the markers from the original snp chip + this causative variant SNPdes the causative variant
    
      } else { 
            # Increment the pruned replicates counter
            disappearance_counter <- disappearance_counter + 1
            #SP$resetPed(lastId = last_bottleneck_IID)
            #SP$resetPed()
        
            if  (disappearance_counter >= disappearance_threshold_value_to_terminate_script ) {  
                # knitr::knit_exit(fully = TRUE) 
                quit(status=1) # Terminate the script if the condition is met
              } 
            else {
              cat("Causative variant did not reach fixation, rerunning simulation...\n")
              cat("f_causative:", f_causative, "\n")
                }
          }
    }
    
} else {
    cat("Skipping this chunk as run_chunks is FALSE.\n")
}

```

```{r}
if (run_chunks) {
  #last_mate_selection_generation <- selection_scenario_pop[[n_generations_mate_selection]]

cat("Population before the selection scenario simulation:\n")
last_bottleneck_generation
cat("\nPopulation after",n_generations_mate_selection,"generations of selection scenario simulation:\n")
last_mate_selection_generation



# Check if Ref_pop_snp_chip is equal to "last_breed_formation_generation"
if (Ref_pop_snp_chip == "last_breed_formation_generation") {
  SP$addSnpChip(
  nSnpPerChr = num_snp_markers_simulated_chromosome,

  refPop = last_mate_selection_generation

  )
  
}
    
} else {
    cat("Skipping this chunk as run_chunks is FALSE.\n")
}
```
# 3: Export Genotype Data
## 3.0.1: Optional: pullSnpGeno() - Retrieves a list of the existing marker id:s (SNP id:s) 
Function that retrieves SNP genotype data & returns a matrix of SNPgenotypes
```{r pullSnpGeno(), echo = FALSE}
#pullSnpGeno(last_mate_selection_generation,simParam=SP)
#snp_chip_genotypes <- pullSnpGeno(last_mate_selection_generation)
#View(snp_chip_genotypes)

```
## 3.0.2: Optional: getSnPMap() - Retrieves a table of the genetic map for the SNP chip
Function that retrieves the genetic map for a given SNP chip & returns a
data.frame with:

-   **id:** Unique identifier for the marker (SNP)

-   **chr:** Chromosome containing the SNP

-   **site:** Segregating site on the chromosome

-   **pos:** Genetic map position

```{r getSnPMap()}
snp_chip_map <- getSnpMap(simParam=SP)
# View(snp_chip_map)
cat("First 10 markers of the SNP chip and their genetic map positions:\n")
kable(head(snp_chip_map,10))
```
## 3.1: writePlink()
**Description** Function that inputs a Pop-class & exports it to PLINK
PED and MAP files.

The arguments for this function were chosen for consistency with
RRBLUP2. **The base pair coordinate will the locus position as stored in
AlphaSimR** & not an actual base pair position, because AlphaSimR
doesn’t track base pair positions, **only relative positions for the
loci used in the simulation**.

\*\* Usage \*\* writePlink( pop, baseName, traits = 1, use = "pheno",
snpChip = 1, useQtl = FALSE, simParam = NULL, ... )

**Arguments:**

-   **pop** an object of Pop-class

-   **baseName** basename for PED and MAP files.

-   **traits** an integer indicating the trait to write, a trait name,
    or a function of the traits returning a single value.

-   **use** what to use for PLINK’s phenotype field. Either phenotypes
    "pheno", genetic values "gv", estimated breeding values "ebv",
    breeding values "bv", or random values "rand".

-   **snpChip** an integer indicating which SNP chip genotype to use
    useQtl should QTL genotypes be used instead of a SNP chip.

    
       -    If TRUE, snpChip specifies which trait’s QTL to use, and thus these QTL may not match the QTL underlying the phenotype supplied in traits.
  

-   **simParam** an object of SimParam ... additional arguments if using
    a function for traits

```{r writePlink()}
if (run_chunks) {
  # Setting the directory where the .map and .ped files will be stored in
  setwd(output_dir_simulation)
  
  writePlink(last_mate_selection_generation,snpChip = 1,simParam=SP, baseName=output_sim_files_basename,
              traits = 1,
             use = "rand"
             )
      
} else {
    cat("Skipping this chunk as run_chunks is FALSE.\n")
}
```
## 3.2: Convert physical distances to basepair in the .map file
```{r map-file PostProcessing}
if (run_chunks) {
  # Setting the working directory as the output directory
  setwd(output_dir_simulation)
  
  # Read PLINK files into R objects
  ped_file <- paste0(output_sim_files_basename, '.ped')
  map_file <- paste0(output_sim_files_basename, '.map')
  ped_data <- read.table(ped_file)
  map_data <- read.table(map_file)
   
  # ¤¤¤¤¤ .map-file Column 1: Changing to correct chromosome ¤¤¤¤¤
  # Change the first column of the .map file to ensure that the correct chromosome number is used
  map_data$V1 <- chr_number
  
  # ¤¤¤¤¤ .map-file Column 2: Changing the SNP IDs to refer to correct chromosome ¤¤¤¤¤
  # Changing the SNP_Ids (second column) so their prefix indicate the correct chromosome number, otherwise 
  # It  will seem like they all belong to chromosome 1, like "1_21".
  # (will be useful if you one would simulate more chromosomes than one)
  map_data$V2 <- gsub("^\\d+_", paste0(chr_number, "_"), map_data$V2)
  
  # ¤¤¤¤¤ .map-file Column 3: Correcting genetic distance column ¤¤¤¤¤
  max_original_genetic_dist <- max(map_data$V3)
  cat("Max genetic distance:",max_original_genetic_dist)
  cat("Simulated Genetic length:",model_chromosome_genetic_length_morgan)
  
  if (ceiling(max_original_genetic_dist) > model_chromosome_genetic_length_morgan*80) {
    genetic_distance_morgan_column <- map_data$V3 / 100 # Extracting the genetic distance column of map_data (3rd column) 
  } else if (ceiling(max_original_genetic_dist) > model_chromosome_genetic_length_morgan*8) {
     genetic_distance_morgan_column <- map_data$V3 / 10 # Extracting the genetic distance column of map_data (3rd column) 
  } else {
    genetic_distance_morgan_column <- map_data$V3 # Extracting the genetic distance column of map_data (3rd column) 
  }
  # ¤¤¤¤¤ .map-file Column 4: Mapping correct bp-positions for the markers ¤¤¤¤¤
  
  base_pair_position_column <- round( (genetic_distance_morgan_column/model_chromosome_genetic_length_morgan) * model_chromosome_physical_length_bp)
  
  # Ensure no positions are 0, replacing 0 with 1
  base_pair_position_column[base_pair_position_column == 0] <- 1
  
  model_chromosome_genetic_length_morgan*10^2
  max(base_pair_position_column)
  
  # Redefining the physical position column (4th column) with the new values defined in base_pair_position_column
  map_data$V4 <- base_pair_position_column
  
  #col.names = FALSE: Removes the header.
  #quote = FALSE: Removes quotation marks from values.
  write.table(map_data, file = map_file, sep = "\t", row.names = FALSE, col.names = FALSE,quote = FALSE)
  
  cat("Showing the first 10 rows of the new .map file:\n")
  kable(head(map_data, 10))
    
} else {
    cat("Skipping this chunk as run_chunks is FALSE.\n")
}

```
# 4: Export Causative Variant Information
## 4.1 Export information about the location of the causative variant
```{r Causative Variant - Physical Position}
if (run_chunks) {
  # setwd(variant_position_dir)
  gen_map <- getGenMap(founderGenomes)
  #View(gen_map)
  causative_variant_relative_SNP_POS <- gen_map[gen_map$id == causative_variant_SNP_ID, ]
  cat("Causative variant:\n",causative_variant_SNP_ID)
  causative_variant_relative_SNP_POS
  cat("\n Relative postions of the causative variant:\n",causative_variant_relative_SNP_POS$pos)
  cat("\n Simulated Genetic Length:",model_chromosome_genetic_length_morgan)
  cat("\n Simulated Physical Length:",model_chromosome_physical_length_bp)

  
  causative_variant_SNP_pos_in_bp <- round( (causative_variant_relative_SNP_POS$pos/ model_chromosome_genetic_length_morgan) * model_chromosome_physical_length_bp)
  cat("Phyiscal Position of the causative variant:",causative_variant_SNP_pos_in_bp)
  
  # Check if the file exists
  if (file.exists(variant_positions_file)) {
      # Read the existing data from the file
      causative_variant_positions_table <- read.table(variant_positions_file, header = FALSE, sep = "\t")
  } else {
      # Create an empty data frame if the file does not exist
      causative_variant_positions_table <- data.frame(V1 = character(), V2 = integer())
  }
  # Check if the output_sim_files_basename already exists in the file
  existing_row_index <- which(causative_variant_positions_table$V1 == output_sim_files_basename)
  
  if (length(existing_row_index) > 0) {
      causative_variant_positions_table$V2[existing_row_index] <- causative_variant_SNP_pos_in_bp
  } else {
      # Create a new row with the output_sim_files_basename and disappearance_counter
      new_row <- data.frame(V1 = output_sim_files_basename, V2 = causative_variant_SNP_pos_in_bp)
      # Append the new row to the existing data
      causative_variant_positions_table <- rbind(causative_variant_positions_table, new_row)
  }
  # Write the updated data back to the file
  write.table(causative_variant_positions_table, file = variant_positions_file, sep = "\t", row.names = FALSE, col.names = FALSE, quote = FALSE)
    
} else {
    cat("Skipping this chunk as run_chunks is FALSE.\n")
}
```
## 4.2: Export an allele frequency plot for the causative variant
```{r Causative Variant - Allele Frequency}
if (run_chunks) {
  setwd(image_output_dir)
  # Format the bp position nicely
  formatted_bp_pos <- format(causative_variant_SNP_pos_in_bp, big.mark = " ")
  
  # Plotting the allele frequency of the causative variant during the mate selection scenario
  # Open a PNG graphics device with the desired filename
  png(paste0(output_sim_files_basename, '.png'))
  # Set the plot title
  plot_title <- sprintf("Causative-Variant Frequency Plot - s=%g (%d replicates pruned) ", s, disappearance_counter)
  # Plot with customized axes labels and title
  plot(f_causative,
       type = "p",
       xlab = "Generation",
       ylab = "Allele Frequency ",
       main = plot_title,
       ylim = c(0, 1)
       )
  # Add text for the bp position of the studied marker inside the plot
  text(x = max(seq_along(f_causative)), y = 0.05, labels = paste("SNP Pos on", chr_simulated, "(bp):", formatted_bp_pos, "bp"), adj = c(1, 0))
  # # Save the plot
  dev.off()
  # Saving the plot-data as a .txtfile
  write.table(f_causative, file = paste0(output_sim_files_basename, '.txt'), sep = "\t", row.names = FALSE, col.names = FALSE,quote = FALSE)
    
} else {
    cat("Skipping this chunk as run_chunks is FALSE.\n")
}
```
## 4.3: Export pruned replicates information
```{r Causative Variant - Pruned Replicates}
if (run_chunks) {
  # setwd(pruned_counts_dir)
  # Print the number of times the causative variant disappeared
  cat("Number of times the causative variant disappeared:\n")
  cat("Disappearance Counter:", disappearance_counter, "\n")  # Print disappearance_counter value to standard output
  # Check if the file exists
  if (file.exists(simulation_prune_count_file)) {
      # Read the existing data from the file
      prune_count_data <- read.table(simulation_prune_count_file, header = FALSE, sep = "\t")
  } else {
      # Create an empty data frame if the file does not exist
      prune_count_data <- data.frame(V1 = character(), V2 = integer())
  }
  # Check if the output_sim_files_basename already exists in the file
  existing_row_index <- which(prune_count_data$V1 == output_sim_files_basename)
  
  if (length(existing_row_index) > 0) {
      # Update the existing row by adding the total disappearance_counter to V2
      disappearance_counter <- disappearance_counter + prune_count_data$V2[existing_row_index]
      prune_count_data$V2[existing_row_index] <- disappearance_counter
  } else {
      # Create a new row with the output_sim_files_basename and disappearance_counter
      new_row <- data.frame(V1 = output_sim_files_basename, V2 = disappearance_counter)
      # Append the new row to the existing data
      prune_count_data <- rbind(prune_count_data, new_row)
  }
  # Write the updated data back to the file
  write.table(prune_count_data, file = simulation_prune_count_file, sep = "\t", row.names = FALSE, col.names = FALSE, quote = FALSE)
    
} else {
    cat("Skipping this chunk as run_chunks is FALSE.\n")
}
```
